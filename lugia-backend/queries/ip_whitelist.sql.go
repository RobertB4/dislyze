// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ip_whitelist.sql

package queries

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const AddIPToWhitelist = `-- name: AddIPToWhitelist :one
INSERT INTO tenant_ip_whitelist (tenant_id, ip_address, label, created_by)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, ip_address, label, created_by, created_at
`

type AddIPToWhitelistParams struct {
	TenantID  pgtype.UUID  `json:"tenant_id"`
	IpAddress netip.Prefix `json:"ip_address"`
	Label     pgtype.Text  `json:"label"`
	CreatedBy pgtype.UUID  `json:"created_by"`
}

func (q *Queries) AddIPToWhitelist(ctx context.Context, arg *AddIPToWhitelistParams) (*TenantIpWhitelist, error) {
	row := q.db.QueryRow(ctx, AddIPToWhitelist,
		arg.TenantID,
		arg.IpAddress,
		arg.Label,
		arg.CreatedBy,
	)
	var i TenantIpWhitelist
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.IpAddress,
		&i.Label,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return &i, err
}

const CheckIPExists = `-- name: CheckIPExists :one
SELECT EXISTS(
    SELECT 1 
    FROM tenant_ip_whitelist 
    WHERE tenant_id = $1 AND ip_address = $2
) AS exists
`

type CheckIPExistsParams struct {
	TenantID  pgtype.UUID  `json:"tenant_id"`
	IpAddress netip.Prefix `json:"ip_address"`
}

func (q *Queries) CheckIPExists(ctx context.Context, arg *CheckIPExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, CheckIPExists, arg.TenantID, arg.IpAddress)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const ClearTenantIPWhitelist = `-- name: ClearTenantIPWhitelist :exec
DELETE FROM tenant_ip_whitelist
WHERE tenant_id = $1
`

func (q *Queries) ClearTenantIPWhitelist(ctx context.Context, tenantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, ClearTenantIPWhitelist, tenantID)
	return err
}

const CountTenantIPWhitelistRules = `-- name: CountTenantIPWhitelistRules :one
SELECT COUNT(*)
FROM tenant_ip_whitelist
WHERE tenant_id = $1
`

func (q *Queries) CountTenantIPWhitelistRules(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountTenantIPWhitelistRules, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateIPWhitelistEmergencyToken = `-- name: CreateIPWhitelistEmergencyToken :one

INSERT INTO ip_whitelist_emergency_tokens (jti)
VALUES ($1)
RETURNING id, jti, used_at, created_at
`

// IP Whitelist Emergency Token Operations
func (q *Queries) CreateIPWhitelistEmergencyToken(ctx context.Context, jti pgtype.UUID) (*IpWhitelistEmergencyToken, error) {
	row := q.db.QueryRow(ctx, CreateIPWhitelistEmergencyToken, jti)
	var i IpWhitelistEmergencyToken
	err := row.Scan(
		&i.ID,
		&i.Jti,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const GetIPWhitelistEmergencyTokenByJTI = `-- name: GetIPWhitelistEmergencyTokenByJTI :one
SELECT id, jti, used_at, created_at
FROM ip_whitelist_emergency_tokens
WHERE jti = $1
`

func (q *Queries) GetIPWhitelistEmergencyTokenByJTI(ctx context.Context, jti pgtype.UUID) (*IpWhitelistEmergencyToken, error) {
	row := q.db.QueryRow(ctx, GetIPWhitelistEmergencyTokenByJTI, jti)
	var i IpWhitelistEmergencyToken
	err := row.Scan(
		&i.ID,
		&i.Jti,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const GetIPWhitelistForMiddleware = `-- name: GetIPWhitelistForMiddleware :many
WITH tenant_features AS (
    SELECT 
        tenants.id,
        (tenants.enterprise_features->'ip_whitelist'->>'enabled')::boolean as ip_whitelist_enabled,
        (tenants.enterprise_features->'ip_whitelist'->>'allow_internal_admin_bypass')::boolean as allow_internal_bypass
    FROM tenants WHERE tenants.id = $1
)
SELECT 
    tenant_features.ip_whitelist_enabled,
    tenant_features.allow_internal_bypass,
    tenant_ip_whitelist.ip_address::text as ip_address
FROM tenant_features
JOIN tenant_ip_whitelist ON tenant_features.id = tenant_ip_whitelist.tenant_id
WHERE tenant_features.ip_whitelist_enabled = true
`

type GetIPWhitelistForMiddlewareRow struct {
	IpWhitelistEnabled  bool   `json:"ip_whitelist_enabled"`
	AllowInternalBypass bool   `json:"allow_internal_bypass"`
	IpAddress           string `json:"ip_address"`
}

func (q *Queries) GetIPWhitelistForMiddleware(ctx context.Context, id pgtype.UUID) ([]*GetIPWhitelistForMiddlewareRow, error) {
	rows, err := q.db.Query(ctx, GetIPWhitelistForMiddleware, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetIPWhitelistForMiddlewareRow{}
	for rows.Next() {
		var i GetIPWhitelistForMiddlewareRow
		if err := rows.Scan(&i.IpWhitelistEnabled, &i.AllowInternalBypass, &i.IpAddress); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetIPWhitelistRuleByID = `-- name: GetIPWhitelistRuleByID :one
SELECT id, tenant_id, ip_address, label, created_by, created_at
FROM tenant_ip_whitelist
WHERE id = $1 AND tenant_id = $2
`

type GetIPWhitelistRuleByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetIPWhitelistRuleByID(ctx context.Context, arg *GetIPWhitelistRuleByIDParams) (*TenantIpWhitelist, error) {
	row := q.db.QueryRow(ctx, GetIPWhitelistRuleByID, arg.ID, arg.TenantID)
	var i TenantIpWhitelist
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.IpAddress,
		&i.Label,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return &i, err
}

const GetTenantIPWhitelist = `-- name: GetTenantIPWhitelist :many
SELECT id, tenant_id, ip_address, label, created_by, created_at
FROM tenant_ip_whitelist
WHERE tenant_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetTenantIPWhitelist(ctx context.Context, tenantID pgtype.UUID) ([]*TenantIpWhitelist, error) {
	rows, err := q.db.Query(ctx, GetTenantIPWhitelist, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TenantIpWhitelist{}
	for rows.Next() {
		var i TenantIpWhitelist
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.IpAddress,
			&i.Label,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTenantIPWhitelistCIDRs = `-- name: GetTenantIPWhitelistCIDRs :many
SELECT ip_address::text as ip_address
FROM tenant_ip_whitelist
WHERE tenant_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetTenantIPWhitelistCIDRs(ctx context.Context, tenantID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, GetTenantIPWhitelistCIDRs, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var ip_address string
		if err := rows.Scan(&ip_address); err != nil {
			return nil, err
		}
		items = append(items, ip_address)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkIPWhitelistEmergencyTokenAsUsed = `-- name: MarkIPWhitelistEmergencyTokenAsUsed :exec
UPDATE ip_whitelist_emergency_tokens
SET used_at = CURRENT_TIMESTAMP
WHERE jti = $1
`

func (q *Queries) MarkIPWhitelistEmergencyTokenAsUsed(ctx context.Context, jti pgtype.UUID) error {
	_, err := q.db.Exec(ctx, MarkIPWhitelistEmergencyTokenAsUsed, jti)
	return err
}

const RemoveIPFromWhitelist = `-- name: RemoveIPFromWhitelist :exec
DELETE FROM tenant_ip_whitelist
WHERE id = $1 AND tenant_id = $2
`

type RemoveIPFromWhitelistParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) RemoveIPFromWhitelist(ctx context.Context, arg *RemoveIPFromWhitelistParams) error {
	_, err := q.db.Exec(ctx, RemoveIPFromWhitelist, arg.ID, arg.TenantID)
	return err
}

const UpdateIPWhitelistLabel = `-- name: UpdateIPWhitelistLabel :exec
UPDATE tenant_ip_whitelist
SET label = $1
WHERE id = $2 AND tenant_id = $3
`

type UpdateIPWhitelistLabelParams struct {
	Label    pgtype.Text `json:"label"`
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) UpdateIPWhitelistLabel(ctx context.Context, arg *UpdateIPWhitelistLabelParams) error {
	_, err := q.db.Exec(ctx, UpdateIPWhitelistLabel, arg.Label, arg.ID, arg.TenantID)
	return err
}
