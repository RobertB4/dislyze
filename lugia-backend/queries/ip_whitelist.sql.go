// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: ip_whitelist.sql

package queries

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const AddIPToWhitelist = `-- name: AddIPToWhitelist :one
INSERT INTO tenant_ip_whitelist (tenant_id, ip_address, label, created_by)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, ip_address, label, created_by, created_at
`

type AddIPToWhitelistParams struct {
	TenantID  pgtype.UUID  `json:"tenant_id"`
	IpAddress netip.Prefix `json:"ip_address"`
	Label     pgtype.Text  `json:"label"`
	CreatedBy pgtype.UUID  `json:"created_by"`
}

func (q *Queries) AddIPToWhitelist(ctx context.Context, arg *AddIPToWhitelistParams) (*TenantIpWhitelist, error) {
	row := q.db.QueryRow(ctx, AddIPToWhitelist,
		arg.TenantID,
		arg.IpAddress,
		arg.Label,
		arg.CreatedBy,
	)
	var i TenantIpWhitelist
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.IpAddress,
		&i.Label,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return &i, err
}

const ClearTenantIPWhitelist = `-- name: ClearTenantIPWhitelist :exec
DELETE FROM tenant_ip_whitelist
WHERE tenant_id = $1
`

func (q *Queries) ClearTenantIPWhitelist(ctx context.Context, tenantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, ClearTenantIPWhitelist, tenantID)
	return err
}

const CountTenantIPWhitelistRules = `-- name: CountTenantIPWhitelistRules :one
SELECT COUNT(*)
FROM tenant_ip_whitelist
WHERE tenant_id = $1
`

func (q *Queries) CountTenantIPWhitelistRules(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountTenantIPWhitelistRules, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateIPWhitelistRevertToken = `-- name: CreateIPWhitelistRevertToken :one

INSERT INTO ip_whitelist_revert_tokens (tenant_id, token_hash, config_snapshot, created_by, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, token_hash, config_snapshot, created_by, expires_at, created_at, used_at
`

type CreateIPWhitelistRevertTokenParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	TokenHash      string             `json:"token_hash"`
	ConfigSnapshot []byte             `json:"config_snapshot"`
	CreatedBy      pgtype.UUID        `json:"created_by"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
}

// IP Whitelist Revert Token Operations
func (q *Queries) CreateIPWhitelistRevertToken(ctx context.Context, arg *CreateIPWhitelistRevertTokenParams) (*IpWhitelistRevertToken, error) {
	row := q.db.QueryRow(ctx, CreateIPWhitelistRevertToken,
		arg.TenantID,
		arg.TokenHash,
		arg.ConfigSnapshot,
		arg.CreatedBy,
		arg.ExpiresAt,
	)
	var i IpWhitelistRevertToken
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TokenHash,
		&i.ConfigSnapshot,
		&i.CreatedBy,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UsedAt,
	)
	return &i, err
}

const GetIPWhitelistForMiddleware = `-- name: GetIPWhitelistForMiddleware :many
WITH tenant_features AS (
    SELECT 
        tenants.id,
        (tenants.enterprise_features->'ip_whitelist'->>'enabled')::boolean as ip_whitelist_enabled,
        (tenants.enterprise_features->'ip_whitelist'->>'allow_internal_admin_bypass')::boolean as allow_internal_bypass
    FROM tenants WHERE tenants.id = $1
)
SELECT 
    tenant_features.ip_whitelist_enabled,
    tenant_features.allow_internal_bypass,
    tenant_ip_whitelist.ip_address::text as ip_address
FROM tenant_features
JOIN tenant_ip_whitelist ON tenant_features.id = tenant_ip_whitelist.tenant_id
WHERE tenant_features.ip_whitelist_enabled = true
`

type GetIPWhitelistForMiddlewareRow struct {
	IpWhitelistEnabled  bool   `json:"ip_whitelist_enabled"`
	AllowInternalBypass bool   `json:"allow_internal_bypass"`
	IpAddress           string `json:"ip_address"`
}

func (q *Queries) GetIPWhitelistForMiddleware(ctx context.Context, id pgtype.UUID) ([]*GetIPWhitelistForMiddlewareRow, error) {
	rows, err := q.db.Query(ctx, GetIPWhitelistForMiddleware, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetIPWhitelistForMiddlewareRow{}
	for rows.Next() {
		var i GetIPWhitelistForMiddlewareRow
		if err := rows.Scan(&i.IpWhitelistEnabled, &i.AllowInternalBypass, &i.IpAddress); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetIPWhitelistRevertTokenByHash = `-- name: GetIPWhitelistRevertTokenByHash :one
SELECT id, tenant_id, token_hash, config_snapshot, created_by, expires_at, created_at, used_at
FROM ip_whitelist_revert_tokens
WHERE token_hash = $1 
AND expires_at > CURRENT_TIMESTAMP 
AND used_at IS NULL
`

func (q *Queries) GetIPWhitelistRevertTokenByHash(ctx context.Context, tokenHash string) (*IpWhitelistRevertToken, error) {
	row := q.db.QueryRow(ctx, GetIPWhitelistRevertTokenByHash, tokenHash)
	var i IpWhitelistRevertToken
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TokenHash,
		&i.ConfigSnapshot,
		&i.CreatedBy,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UsedAt,
	)
	return &i, err
}

const GetTenantIPWhitelist = `-- name: GetTenantIPWhitelist :many
SELECT id, tenant_id, ip_address, label, created_by, created_at
FROM tenant_ip_whitelist
WHERE tenant_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetTenantIPWhitelist(ctx context.Context, tenantID pgtype.UUID) ([]*TenantIpWhitelist, error) {
	rows, err := q.db.Query(ctx, GetTenantIPWhitelist, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TenantIpWhitelist{}
	for rows.Next() {
		var i TenantIpWhitelist
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.IpAddress,
			&i.Label,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTenantIPWhitelistCIDRs = `-- name: GetTenantIPWhitelistCIDRs :many
SELECT ip_address::text as ip_address
FROM tenant_ip_whitelist
WHERE tenant_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetTenantIPWhitelistCIDRs(ctx context.Context, tenantID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, GetTenantIPWhitelistCIDRs, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var ip_address string
		if err := rows.Scan(&ip_address); err != nil {
			return nil, err
		}
		items = append(items, ip_address)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTenantIPWhitelistSnapshot = `-- name: GetTenantIPWhitelistSnapshot :many
SELECT 
    ip_address::text as ip_address,
    label,
    created_by,
    created_at
FROM tenant_ip_whitelist
WHERE tenant_id = $1
ORDER BY created_at ASC
`

type GetTenantIPWhitelistSnapshotRow struct {
	IpAddress string             `json:"ip_address"`
	Label     pgtype.Text        `json:"label"`
	CreatedBy pgtype.UUID        `json:"created_by"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Helper query to get current IP whitelist configuration for snapshots
func (q *Queries) GetTenantIPWhitelistSnapshot(ctx context.Context, tenantID pgtype.UUID) ([]*GetTenantIPWhitelistSnapshotRow, error) {
	rows, err := q.db.Query(ctx, GetTenantIPWhitelistSnapshot, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTenantIPWhitelistSnapshotRow{}
	for rows.Next() {
		var i GetTenantIPWhitelistSnapshotRow
		if err := rows.Scan(
			&i.IpAddress,
			&i.Label,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByIPWhitelistEditPermission = `-- name: GetUsersByIPWhitelistEditPermission :many
WITH users_with_permission AS (
    SELECT DISTINCT user_roles.user_id
    FROM user_roles
    JOIN roles ON user_roles.role_id = roles.id
    JOIN role_permissions ON roles.id = role_permissions.role_id
    JOIN permissions ON role_permissions.permission_id = permissions.id
    WHERE user_roles.tenant_id = $1
    AND permissions.resource = 'ip_whitelist'
    AND permissions.action = 'edit'
    AND (
        $2 = true OR  -- RBAC enabled: use all roles
        roles.is_default = true      -- RBAC disabled: only default roles
    )
)
SELECT users.id, users.email, users.name
FROM users
JOIN users_with_permission ON users.id = users_with_permission.user_id
WHERE users.tenant_id = $1
AND users.status = 'active'
`

type GetUsersByIPWhitelistEditPermissionParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	RbacEnabled interface{} `json:"rbac_enabled"`
}

type GetUsersByIPWhitelistEditPermissionRow struct {
	ID    pgtype.UUID `json:"id"`
	Email string      `json:"email"`
	Name  string      `json:"name"`
}

func (q *Queries) GetUsersByIPWhitelistEditPermission(ctx context.Context, arg *GetUsersByIPWhitelistEditPermissionParams) ([]*GetUsersByIPWhitelistEditPermissionRow, error) {
	rows, err := q.db.Query(ctx, GetUsersByIPWhitelistEditPermission, arg.TenantID, arg.RbacEnabled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUsersByIPWhitelistEditPermissionRow{}
	for rows.Next() {
		var i GetUsersByIPWhitelistEditPermissionRow
		if err := rows.Scan(&i.ID, &i.Email, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkIPWhitelistRevertTokenAsUsed = `-- name: MarkIPWhitelistRevertTokenAsUsed :exec
UPDATE ip_whitelist_revert_tokens
SET used_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) MarkIPWhitelistRevertTokenAsUsed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, MarkIPWhitelistRevertTokenAsUsed, id)
	return err
}

const RemoveIPFromWhitelist = `-- name: RemoveIPFromWhitelist :exec
DELETE FROM tenant_ip_whitelist
WHERE id = $1 AND tenant_id = $2
`

type RemoveIPFromWhitelistParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) RemoveIPFromWhitelist(ctx context.Context, arg *RemoveIPFromWhitelistParams) error {
	_, err := q.db.Exec(ctx, RemoveIPFromWhitelist, arg.ID, arg.TenantID)
	return err
}

type RestoreIPWhitelistFromSnapshotParams struct {
	TenantID  pgtype.UUID        `json:"tenant_id"`
	IpAddress netip.Prefix       `json:"ip_address"`
	Label     pgtype.Text        `json:"label"`
	CreatedBy pgtype.UUID        `json:"created_by"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

const UpdateIPWhitelistLabel = `-- name: UpdateIPWhitelistLabel :exec
UPDATE tenant_ip_whitelist
SET label = $1
WHERE id = $2 AND tenant_id = $3
`

type UpdateIPWhitelistLabelParams struct {
	Label    pgtype.Text `json:"label"`
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) UpdateIPWhitelistLabel(ctx context.Context, arg *UpdateIPWhitelistLabelParams) error {
	_, err := q.db.Exec(ctx, UpdateIPWhitelistLabel, arg.Label, arg.ID, arg.TenantID)
	return err
}
