// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: roles.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CheckRoleInUse = `-- name: CheckRoleInUse :one
SELECT EXISTS(
    SELECT 1 FROM user_roles
    WHERE role_id = $1 AND tenant_id = $2
) as exists
`

type CheckRoleInUseParams struct {
	RoleID   pgtype.UUID `json:"role_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CheckRoleInUse(ctx context.Context, arg *CheckRoleInUseParams) (bool, error) {
	row := q.db.QueryRow(ctx, CheckRoleInUse, arg.RoleID, arg.TenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const CheckRoleNameExists = `-- name: CheckRoleNameExists :one
SELECT EXISTS(
    SELECT 1 FROM roles 
    WHERE tenant_id = $1 AND name = $2 AND id != $3
) as exists
`

type CheckRoleNameExistsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Name     string      `json:"name"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) CheckRoleNameExists(ctx context.Context, arg *CheckRoleNameExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, CheckRoleNameExists, arg.TenantID, arg.Name, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const CreateRole = `-- name: CreateRole :one
INSERT INTO roles (tenant_id, name, description, is_default)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, name, description, created_at, updated_at
`

type CreateRoleParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	IsDefault   bool        `json:"is_default"`
}

type CreateRoleRow struct {
	ID          pgtype.UUID        `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateRole(ctx context.Context, arg *CreateRoleParams) (*CreateRoleRow, error) {
	row := q.db.QueryRow(ctx, CreateRole,
		arg.TenantID,
		arg.Name,
		arg.Description,
		arg.IsDefault,
	)
	var i CreateRoleRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateRolePermissionsBulk = `-- name: CreateRolePermissionsBulk :exec
INSERT INTO role_permissions (role_id, permission_id, tenant_id)
SELECT $1, UNNEST($2::uuid[]), $3
`

type CreateRolePermissionsBulkParams struct {
	RoleID        pgtype.UUID   `json:"role_id"`
	PermissionIds []pgtype.UUID `json:"permission_ids"`
	TenantID      pgtype.UUID   `json:"tenant_id"`
}

func (q *Queries) CreateRolePermissionsBulk(ctx context.Context, arg *CreateRolePermissionsBulkParams) error {
	_, err := q.db.Exec(ctx, CreateRolePermissionsBulk, arg.RoleID, arg.PermissionIds, arg.TenantID)
	return err
}

const DeleteRole = `-- name: DeleteRole :exec
DELETE FROM roles
WHERE id = $1 AND tenant_id = $2 AND is_default = false
`

type DeleteRoleParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteRole(ctx context.Context, arg *DeleteRoleParams) error {
	_, err := q.db.Exec(ctx, DeleteRole, arg.ID, arg.TenantID)
	return err
}

const DeleteRolePermissions = `-- name: DeleteRolePermissions :exec
DELETE FROM role_permissions
WHERE role_id = $1 AND tenant_id = $2
`

type DeleteRolePermissionsParams struct {
	RoleID   pgtype.UUID `json:"role_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteRolePermissions(ctx context.Context, arg *DeleteRolePermissionsParams) error {
	_, err := q.db.Exec(ctx, DeleteRolePermissions, arg.RoleID, arg.TenantID)
	return err
}

const GetAllPermissions = `-- name: GetAllPermissions :many
SELECT id, resource, action, description FROM permissions
`

type GetAllPermissionsRow struct {
	ID          pgtype.UUID `json:"id"`
	Resource    string      `json:"resource"`
	Action      string      `json:"action"`
	Description string      `json:"description"`
}

func (q *Queries) GetAllPermissions(ctx context.Context) ([]*GetAllPermissionsRow, error) {
	rows, err := q.db.Query(ctx, GetAllPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllPermissionsRow{}
	for rows.Next() {
		var i GetAllPermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Resource,
			&i.Action,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDefaultViewerRole = `-- name: GetDefaultViewerRole :one
SELECT id, tenant_id, name, description, is_default, created_at, updated_at FROM roles
WHERE tenant_id = $1 AND is_default = true AND name = '閲覧者'
`

func (q *Queries) GetDefaultViewerRole(ctx context.Context, tenantID pgtype.UUID) (*Role, error) {
	row := q.db.QueryRow(ctx, GetDefaultViewerRole, tenantID)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetRoleByID = `-- name: GetRoleByID :one
SELECT id, tenant_id, name, description, is_default, created_at, updated_at FROM roles
WHERE id = $1 AND tenant_id = $2
`

type GetRoleByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetRoleByID(ctx context.Context, arg *GetRoleByIDParams) (*Role, error) {
	row := q.db.QueryRow(ctx, GetRoleByID, arg.ID, arg.TenantID)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetTenantRolesWithPermissions = `-- name: GetTenantRolesWithPermissions :many
SELECT 
    roles.id, roles.name, roles.description, roles.is_default,
    permissions.id as permission_id,
    permissions.resource,
    permissions.action,
    permissions.description as permission_description
FROM roles
LEFT JOIN role_permissions ON roles.id = role_permissions.role_id
LEFT JOIN permissions ON role_permissions.permission_id = permissions.id
WHERE roles.tenant_id = $1
ORDER BY roles.name, permissions.description
`

type GetTenantRolesWithPermissionsRow struct {
	ID                    pgtype.UUID `json:"id"`
	Name                  string      `json:"name"`
	Description           pgtype.Text `json:"description"`
	IsDefault             bool        `json:"is_default"`
	PermissionID          pgtype.UUID `json:"permission_id"`
	Resource              pgtype.Text `json:"resource"`
	Action                pgtype.Text `json:"action"`
	PermissionDescription pgtype.Text `json:"permission_description"`
}

func (q *Queries) GetTenantRolesWithPermissions(ctx context.Context, tenantID pgtype.UUID) ([]*GetTenantRolesWithPermissionsRow, error) {
	rows, err := q.db.Query(ctx, GetTenantRolesWithPermissions, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTenantRolesWithPermissionsRow{}
	for rows.Next() {
		var i GetTenantRolesWithPermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsDefault,
			&i.PermissionID,
			&i.Resource,
			&i.Action,
			&i.PermissionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateRole = `-- name: UpdateRole :exec
UPDATE roles
SET name = $1, description = $2
WHERE id = $3 AND tenant_id = $4 AND is_default = false
`

type UpdateRoleParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg *UpdateRoleParams) error {
	_, err := q.db.Exec(ctx, UpdateRole,
		arg.Name,
		arg.Description,
		arg.ID,
		arg.TenantID,
	)
	return err
}

const ValidateRolesBelongToTenant = `-- name: ValidateRolesBelongToTenant :many
SELECT id FROM roles 
WHERE id = ANY($1::uuid[]) AND tenant_id = $2
`

type ValidateRolesBelongToTenantParams struct {
	Column1  []pgtype.UUID `json:"column_1"`
	TenantID pgtype.UUID   `json:"tenant_id"`
}

func (q *Queries) ValidateRolesBelongToTenant(ctx context.Context, arg *ValidateRolesBelongToTenantParams) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, ValidateRolesBelongToTenant, arg.Column1, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
